defmodule Deft.Subtyping.Lattice do
  @moduledoc """
  The subtyping lattice built from type module metadata.

  Modules are discovered dynamically by scanning for those that export
  `__subtyping_metadata__/0`, which is generated by `use Deft.Subtyping.DSL`.

  Provides introspection APIs for querying the lattice structure.
  """

  alias Deft.Type

  @doc """
  Returns all type modules participating in the lattice.

  Modules are discovered by scanning for those that define `__subtyping_metadata__/0`.
  """
  @spec type_modules() :: [module()]
  def type_modules do
    :code.all_loaded()
    |> Enum.map(fn {mod, _path} -> mod end)
    |> Enum.filter(&has_metadata?/1)
  end

  @doc """
  Returns all declared edges in the lattice as `{subtype, supertype}` tuples.

  This only includes direct declarations via `subtype_of`, not transitive
  or structural relationships.
  """
  @spec edges() :: [{module(), module()}]
  def edges do
    for mod <- type_modules(),
        supertype <- mod.__subtyping_metadata__().supertypes do
      {mod, supertype}
    end
  end

  # Returns the immediate declared supertypes of a type module.
  defp immediate_supertypes(type_module) do
    if has_metadata?(type_module) do
      type_module.__subtyping_metadata__().supertypes
    else
      []
    end
  end

  # Returns the immediate declared subtypes of a type module.
  defp immediate_subtypes(type_module) do
    for mod <- type_modules(),
        type_module in mod.__subtyping_metadata__().supertypes do
      mod
    end
  end

  @doc """
  Returns all supertypes of a type module (transitive closure).

  Includes Top for all types.
  """
  @spec supertypes_of(module()) :: [module()]
  def supertypes_of(type_module) do
    direct = immediate_supertypes(type_module)
    transitive = Enum.flat_map(direct, &supertypes_of/1)
    result = Enum.uniq(direct ++ transitive)

    # Top is supertype of everything except itself
    if type_module != Type.Top and Type.Top not in result do
      result ++ [Type.Top]
    else
      result
    end
  end

  @doc """
  Returns all subtypes of a type module (transitive closure).

  Includes Bottom for all types.
  """
  @spec subtypes_of(module()) :: [module()]
  def subtypes_of(type_module) do
    direct = immediate_subtypes(type_module)
    transitive = Enum.flat_map(direct, &subtypes_of/1)
    result = Enum.uniq(direct ++ transitive)

    # Bottom is subtype of everything except itself
    if type_module != Type.Bottom and Type.Bottom not in result do
      result ++ [Type.Bottom]
    else
      result
    end
  end

  @doc """
  Returns variance metadata for a type module's parameters.

  Returns a keyword list of `{parameter_name, variance}`.
  """
  @spec variance_of(module()) :: keyword(Deft.Subtyping.Variance.t())
  def variance_of(type_module) do
    if has_metadata?(type_module) do
      type_module.__subtyping_metadata__().parameters
    else
      []
    end
  end

  @doc """
  Returns true if the type module has a structural subtyping rule.
  """
  @spec has_structural_rule?(module()) :: boolean()
  def has_structural_rule?(type_module) do
    if has_metadata?(type_module) do
      type_module.__subtyping_metadata__().has_structural_rule?
    else
      false
    end
  end

  @doc """
  Returns true if the type module has a check_subtype function for detailed error reporting.
  """
  @spec has_check_subtype?(module()) :: boolean()
  def has_check_subtype?(type_module) do
    if has_metadata?(type_module) do
      Map.get(type_module.__subtyping_metadata__(), :has_check_subtype?, false)
    else
      false
    end
  end

  defp has_metadata?(mod) do
    Code.ensure_loaded?(mod) and function_exported?(mod, :__subtyping_metadata__, 0)
  end
end
